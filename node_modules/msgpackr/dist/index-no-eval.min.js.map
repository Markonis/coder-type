{"version":3,"file":"index-no-eval.min.js","sources":["../unpack.js","../pack.js","../iterators.js","../index.js"],"sourcesContent":["var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, end) {\n\t\treturn this.unpack(source, end)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + JSON.stringify(result).slice(0, 100))\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (globalThis[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new globalThis[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\tif (structures.length > sharedLength)\n\t\t\t\t\t\tstructures.length = sharedLength\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tstructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t}\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\treturn packr.pack(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (let [ key, entryValue ] of value) {\n\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else if (type === 'function') {\n\t\t\t\tpack(this.writeFunction && this.writeFunction()) // if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writeObject = this.useRecords === false ? this.variableMapSize ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(key = keys[i])\n\t\t\t\tpack(object[key])\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t} :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tpack(object[key])\n\t\t}\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\n","import { Packr } from './pack.js'\nimport { Unpackr } from './unpack.js'\n\n/**\n * Given an Iterable first argument, returns an Iterable where each value is packed as a Buffer\n * If the argument is only Async Iterable, the return value will be an Async Iterable.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterator} objectIterator - iterable source, like a Readable object stream, an array, Set, or custom object\n * @param {options} [options] - msgpackr pack options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator>}\n */\nexport function packIter (objectIterator, options = {}) {\n  if (!objectIterator || typeof objectIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, or a Promise for an Async Iterable')\n  } else if (typeof objectIterator[Symbol.iterator] === 'function') {\n    return packIterSync(objectIterator, options)\n  } else if (typeof objectIterator.then === 'function' || typeof objectIterator[Symbol.asyncIterator] === 'function') {\n    return packIterAsync(objectIterator, options)\n  } else {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a Promise')\n  }\n}\n\nfunction * packIterSync (objectIterator, options) {\n  const packr = new Packr(options)\n  for (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\nasync function * packIterAsync (objectIterator, options) {\n  const packr = new Packr(options)\n  for await (const value of objectIterator) {\n    yield packr.pack(value)\n  }\n}\n\n/**\n * Given an Iterable/Iterator input which yields buffers, returns an IterableIterator which yields sync decoded objects\n * Or, given an Async Iterable/Iterator which yields promises resolving in buffers, returns an AsyncIterableIterator.\n * @param {Iterable|Iterator|AsyncIterable|AsyncIterableIterator} bufferIterator\n * @param {object} [options] - unpackr options\n * @returns {IterableIterator|Promise.<AsyncIterableIterator}\n */\nexport function unpackIter (bufferIterator, options = {}) {\n  if (!bufferIterator || typeof bufferIterator !== 'object') {\n    throw new Error('first argument must be an Iterable, Async Iterable, Iterator, Async Iterator, or a promise')\n  }\n\n  const unpackr = new Unpackr(options)\n  let incomplete\n  const parser = (chunk) => {\n    let yields\n    // if there's incomplete data from previous chunk, concatinate and try again\n    if (incomplete) {\n      chunk = Buffer.concat([incomplete, chunk])\n      incomplete = undefined\n    }\n\n    try {\n      yields = unpackr.unpackMultiple(chunk)\n    } catch (err) {\n      if (err.incomplete) {\n        incomplete = chunk.slice(err.lastPosition)\n        yields = err.values\n      } else {\n        throw err\n      }\n    }\n    return yields\n  }\n\n  if (typeof bufferIterator[Symbol.iterator] === 'function') {\n    return (function * iter () {\n      for (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  } else if (typeof bufferIterator[Symbol.asyncIterator] === 'function') {\n    return (async function * iter () {\n      for await (const value of bufferIterator) {\n        yield * parser(value)\n      }\n    })()\n  }\n}\nexport const decodeIter = unpackIter\nexport const encodeIter = packIter","export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT, REUSE_BUFFER_MODE } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\n"],"names":["decoder","src","srcEnd","TextDecoder","error","currentStructures","srcString","bundledStrings","referenceMap","dataView","position","currentUnpackr","srcStringStart","srcStringEnd","currentExtensions","defaultOptions","useRecords","mapsAsObjects","C1Type","C1","name","BlockedFunction","sequentialMode","inlineObjectReadThreshold","Infinity","Unpackr","constructor","options","undefined","sequential","trusted","structures","maxSharedStructures","sharedLength","length","getStructures","uninitialized","int64AsNumber","int64AsType","Object","assign","this","unpack","source","saveState","clearSource","prototype","call","end","start","DataView","buffer","byteOffset","byteLength","Uint8Array","Error","checkedRead","unpackMultiple","forEach","values","lastPosition","size","value","defaultUnpackr","push","_mergeStructures","loadedStructures","existingStructures","isFrozen","map","structure","slice","i","l","isShared","highByte","id","existing","restoreStructures","decode","result","randomAccessStructure","read","postBundlePosition","JSON","stringify","RangeError","message","startsWith","incomplete","token","loadStructures","createStructureReader","object","key","readKey","Map","set","array","Array","freezeData","freeze","string","shortStringInJS","longStringInJS","readFixedString","position1","position0","readBin","getUint16","getUint32","readExt","getFloat32","useFloat32","multiplier","mult10","getFloat64","getBigUint64","toString","getInt8","getInt16","getInt32","getBigInt64","recordDefinition","extension","noBuffer","subarray","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","count","test","join","createSecondByteReader","read0","readStringJS","units","byte1","byte2","byte3","unit","fromCharCode","apply","String","bytes","byte","a","b","c","d","e","f","g","h","j","k","m","n","o","readOnlyJSString","copyBuffers","type","readPosition","keyCache","chunk","entry","checkPosition","property","firstByte","existingStructure","data","globalThis","target","refEntry","targetProperties","used","get","Set","typedArrays","typeCode","typedArrayName","RegExp","TEMP_BUNDLE","callback","savedSrcEnd","savedPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","splice","dataSize","dataPosition","Date","Math","floor","Decoder","FLOAT32_OPTIONS","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","textEncoder","extensions","extensionClasses","f32Array","Float32Array","u8Array","TextEncoder","hasNodeBuffer","Buffer","ByteArrayAllocate","allocUnsafeSlow","ByteArray","MAX_BUFFER_SIZE","keysTarget","targetView","safeEnd","hasNonLatin","RECORD_SYMBOL","Symbol","Packr","hasSharedUpdate","super","offset","encodeUtf8","utf8Write","encodeInto","written","packr","isSequential","hasSharedStructures","saveStructures","structuredClone","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","pack","encode","encodeOptions","bundleStrings","transitions","create","keys","nextTransition","transition","lastNamedStructuresLength","nextId","writeStruct","lastBundle","writeBundles","idsToInsert","sort","incrementPosition","insertionPoint","stringsPosition","setUint32","previous","makeRoom","serialized","distanceToMove","lastEnd","pop","copyWithin","insertIds","REUSE_BUFFER_MODE","returnBuffer","newSharedData","isCompatible","compatible","prepareStructures","RESET_BUFFER_MODE","packArray","headerSize","strLength","extStart","maxBytes","setUint16","twoByte","c1","c2","strPosition","charCodeAt","setInt16","setInt32","xShifted","setFloat32","setFloat64","referee","writeObject","entryValue","write","writeResult","isArray","currentTarget","currentTargetView","currentPosition","writeExtensionData","hasOwnProperty","BigInt","setBigInt64","setBigUint64","largeBigIntToFloat","Number","encodeUndefinedAsNil","writeFunction","variableMapSize","safePrototype","objectOffset","progressiveRecords","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","__keys__","newSize","min","round","max","newBuffer","copy","shouldShareStructure","nextOwnId","shift","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","writeStructSlots","notifySharedUpdate","startTarget","useBuffer","clearSharedData","typedStructs","writeExtBuffer","typedArray","allocateForWrite","writeBuffer","writeStrings","ArrayBuffer","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","isNaN","onInvalidDate","from","regex","flags","arrayBuffer","indexOf","defaultPackr","Encoder","decodeIter","bufferIterator","unpackr","parser","yields","concat","err","iterator","asyncIterator","encodeIter","objectIterator","packIterSync","then","async","packIterAsync","Class","unshift","unpackAddExtension","float32Number"],"mappings":"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"}